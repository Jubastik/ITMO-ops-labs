# Оглавление

1. Краткое описание
2. Best practices  
   2.1 Описание  
   2.2 Базовая версия Python  
   2.3 Настройка Python с помощью ENV переменных  
   2.4 Использование "слоистости" python  
   2.5 Двухэтапная сборка  
   2.6 .dockerignore
3. Настройка сети docker-compose
4. Bad practices при работе с "хорошими" Dockerfile
5. Bad practices docker-compose  
   5.1 Описание  
   5.2 network_mode - host  
   5.3 Избыточное монтирование volume  
   5.4 "Хардкод" environment
   5.5 Игнорирование depends_on
6. Используемые ресурсы

## 1. Краткое описание

Для решения лабораторной работы были взяты два FastApi приложения из лабораторной работы №1.  
Добавлены "хорошие" Dockerfile. Изменен docker-compose так, чтобы приложения не видели друг друга.
Добавлены "плохие" docker-compose.

## 2. Best practices

### 2.1 Описание

Best practices использованы в файле "Dockerfile".  
Благодаря их использованию увеличилось скорость сборки образа, уменьшился размер образа, увеличилась безопасность.

Вес собранного образа уменьшился с 1.04 гб до 150 мб.

### 2.2 Базовая версия Python

Был использован официальный образ python:3.12-slim-bookworm. Почему именно он?

- python 3.12 - новейшая стабильная версия python
- slim - минимальный образ. В нем нет лишних пакетов, которые могут увеличить размер образа, а также увеличить
  поверхность атаки. slim весит больше чем alpine,
  однако alpine имеет проблемы с совместимостью и временем сборки некоторых пакетов
- bookworm - версия debian. Просто закрепил конкретную версию

### 2.3 Настройка Python с помощью ENV переменных

Были использованы 2 настройки python рекомендованные для Dockerfile:

- PYTHONDONTWRITEBYTECODE - не создавать .pyc файлы
- PYTHONUNBUFFERED - не буферизировать вывод. Это позволяет гарантированно выводить логи сразу

### 2.4 Использование "слоистости" python

Слои позволяют переиспользовать кэш сборки, тем самым ускорив ее. Поэтому логично располагать часто меняющиеся слои как
можно ниже.

Например в DockerfileHorrible изменение кода приводит к переустановке requirements.txt, что не оптимально.

### 2.5 Двухэтапная сборка

Пункт дополняющий предыдущий. Двухэтапная сборка позволяет уменьшить размер образа, так как в финальном образе будут
отсутствовать зависимости необходимые для промежуточных этапов. Для Python не супер критично, однако для компилируемых
языков
двухэтапная сборка позволяет колоссально выиграть в размере и перенести компиляцию с сервера на локальную/build машину.

Также двухэтапная сборка помогает лучше использовать слоистость Docker.

### 2.6 .dockerignore

Файл .dockerignore позволяет игнорировать при копировании файлы и папки, которые не нужны.

## 3. Настройка сети docker-compose

В существующий docker-compose были добавлены 2 сети: net_app1 и net_app2. Nginx добавлен в обе, app1 и app2 только в
свои сети.

## 4. Bad practices при работе с "хорошими" Dockerfile

- Не давать имя контейнеру. Тем самым усложняется работа с ним
- Постоянное использование --no-cache. Это приводит к тому, что кэш не используется, это увеличивает время
  сборки

## 5. Bad practices docker-compose

### 5.1 Описание

Сделать плохой docker-compose сложнее чем Dockerfile, однако все же можно. Пример плохого docker-compose можно увидеть в
docker-compose-horrible.yml

### 5.2 network_mode - host

Используя network_mode: host, контейнеры используют сеть хоста. Это может показаться удобным, так как не нужно
пробрасывать порты, однако это огромная уязвимость. По сути мы убираем сетевую изоляцию контейнера.  
При работе с контейнерами считается хорошим тоном давать им минимальные права. Поэтому лучше сервисы разграничивать
разными сетями, как это сделано в docker-compose.yml.

### 5.3 Избыточное монтирование volume

Опять же. Чем меньше прав, тем лучше. Монтировать необходимо наименьшее количество файлов. Лучше необходимое копировать
на этапе сборки. А если нужно хранилище например для базы данных, лучше использовать volume.

### 5.4 "Хардкод" environment

В docker-compose-horrible.yml переменные окружения прописаны в самом файле. Это плохо, лучше использовать .env файлы или
загружать их из переменных окружения.

### 5.5 Игнорирование depends_on

Хоть depends_on и не гарантирует, что сервис будет готов к работе, однако это лучше чем ничего. По-хорошему с depends_on
надо использовать специальные скрипты для проверки готовности сервиса.

## 6. Используемые ресурсы

- https://habr.com/ru/companies/wunderfund/articles/586778/
- https://snyk.io/blog/best-practices-containerizing-python-docker/