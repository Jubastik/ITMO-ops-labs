# Оглавление

1. Краткое описание
2. Best practices  
   2.1 Описание  
   2.2 Базовая версия Python  
   2.3 Настройка Python с помощью ENV переменных  
   2.4 Использование "слоистости" python  
   2.5 Двухэтапная сборка  
   2.6 .dockerignore
3. Настройка сети docker-compose
4. Bad practices при работе с "хорошими" Dockerfile
5. Используемые ресурсы

## 1. Краткое описание

Для решения лабораторной работы были взяты два FastApi приложения из лабораторной работы №1.  
Добавлены "хорошие" Dockerfile. Изменен docker-compose так, чтобы приложения не видели друг друга.

## 2. Best practices

### 2.1 Описание

Best practices использованы в файле "Dockerfile".  
Благодаря их использованию увеличилось скорость сборки образа, уменьшился размер образа, увеличилась безопасность.

Вес собранного образа уменьшился с 1.04 гб до 150 мб.

### 2.2 Базовая версия Python

Был использован официальный образ python:3.12-slim-bookworm. Почему именно он?

- python 3.12 - новейшая стабильная версия python
- slim - минимальный образ. В нем нет лишних пакетов, которые могут увеличить размер образа, а также увеличить
  поверхность атаки. slim весит больше чем alpine,
  однако alpine имеет проблемы с совместимостью и временем сборки некоторых пакетов
- bookworm - версия debian. Просто закрепил конкретную версию

### 2.3 Настройка Python с помощью ENV переменных

Были использованы 2 настройки python рекомендованные для Dockerfile:

- PYTHONDONTWRITEBYTECODE - не создавать .pyc файлы
- PYTHONUNBUFFERED - не буферизировать вывод. Это позволяет гарантированно выводить логи сразу

### 2.4 Использование "слоистости" python

Слои позволяют переиспользовать кэш сборки, тем самым ускорив ее. Поэтому логично располагать часто меняющиеся слои как
можно ниже.

Например в DockerfileHorrible изменение кода приводит к переустановке requirements.txt, что не оптимально.

### 2.5 Двухэтапная сборка

Пункт дополняющий предыдущий. Двухэтапная сборка позволяет уменьшить размер образа, так как в финальном образе будут
отсутствовать зависимости необходимые для промежуточных этапов. Для Python не супер критично, однако для компилируемых
языков
двухэтапная сборка позволяет колоссально выиграть в размере и перенести компиляцию с сервера на локальную/build машину.

Также двухэтапная сборка помогает лучше использовать слоистость Docker.

### 2.6 .dockerignore

Файл .dockerignore позволяет игнорировать при копировании файлы и папки, которые не нужны.

## 3. Настройка сети docker-compose

В существующий docker-compose были добавлены 2 сети: net_app1 и net_app2. Nginx добавлен в обе, app1 и app2 только в
свои сети.

## 4. Bad practices при работе с "хорошими" Dockerfile

- Не давать имя контейнеру. Тем самым усложняется работа с ним
- Постоянное использование --no-cache. Это приводит к тому, что кэш не используется, это увеличивает время
  сборки

## 5. Используемые ресурсы

- https://habr.com/ru/companies/wunderfund/articles/586778/
- https://snyk.io/blog/best-practices-containerizing-python-docker/